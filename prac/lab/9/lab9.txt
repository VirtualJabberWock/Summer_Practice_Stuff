13.07.2023

Язык C++

Часть 1.

1) доступны старые заголовочный файлы, но появились их новые версии с префиксом "c"
stdio.h -> cstdio

2) переменные могут объявляться по месту использования, а не в начале блока; рекомендуется объявлять их как можно ближе к месту использования

3) появились ссылки
Ссылки имеют синтаксис передачи по значению, а семантику указателя.

4) появились константы, которые следует использовать вместо макросов

5) константные ссылки, константные указатели, указатели на константу (константный указатель на константу)

6) пространства имён

7) использование потоков ввода/вывода вместо старых функций printf, scanf и т.д.

8) перегрузка функций - возможность определять функции с одним именем, но разными аргументами
перегрузка возможна:
- по количеству аргументов
- по типу аргументов
- по константности (для методов класса)

Перегрузка - одна из разновидностей полиморфизма

9) перегрузка операций
синтаксически это происходит просто как объявление функции с особым именем:
operator=, operator+, ...
нельзя перегружать операции . :: .*

нельзя перегружать операции, у которых все аргументы встроенных типов

10) возможность использования пользовательских типов данных так же (почти), как и встроенных

11) создание динамическим объектов с помощью оператора new, создание динамических массивов объектов с помощью оператора new[], уничтожение динамических объектов - delete, уничтожение динамических массивов - delete []

12) поддержка классов
Для чего можно использовать:
- позволяют создавать пользовательские типы данных, похожие на встроенные
- для статического (с помощью шаблонов) и динамического полиморфизма (с помощью наследования и виртуальных методов)
- повторное использование кода
- объектно-ориентированного проектирования
- объектно-ориентированного программирования


У классов есть поля (атрибуты, свойства) и методы (функции-члены).

Класс - абстрактный тип данных, определяемый пользователем

Классы и структуры почти идентичны. Единственное отличие, что если не указать модификаторы доступа (public, private), то в классе все поля будут закрытыми (private), а в структуре - открытыми (public).

13) В классах предусмотрены специальные функции инициализации (конструтор) и завершения (деструктор).
И язык нам гарантирует, что перед использованием будет автоматически вызван конструктор, а перед удаление переменной класса будет вызван деструктор.
Если мы сами не определим конструктор и деструктор, то компилятор их сделает за нас.

Конструкторы можно перегружать как и другие функции.

Методы класса описанные в самом классе являются подставляемыми (inline) функциями.


Нестатические методы класса неявно принимают указатель на объект, для которого они вызваны. К полям этого объекта можно обращаться просто по имени.
Этот указатель называется this:
ClassType * const this;

Операции можно перегружать, определяя их как методы класса. В этом случае первым (или единственным) аргументом будет объект этого класса, доступный внутри определения операции через this.


Часть 2.

14) Константные методы класса.
Для константных объектов могут быть вызваны только константные методы. Для неконстантных объектов - любые.
Константые методы не могут вызывать неконстантные методы и не могут изменять поля класса.
Для неконстантных методов передаётся указатель на объект:
ClassType * const this;		// константный указатель
Для константных методов передаётся указатель на объект:
const ClassType * const this;	// константный указатель на константу

Все методы, которые возможно, должны быть помечены как константные.

Пример examples\1.


15) Компилятор может создавать (если это не сделали мы) некоторые методы класса:
- конструктор по умолчанию (если нами не был определён ни один конструктор)
  вызывает конструкторы по умолчанию для всех полей класса
- копирующий конструктор
  вызывает копирующие конструкторы для всех полей класса
- деструктор
  вызывает декструкторы для всех полей класса
- операция присваивания (operator=)
  вызывает операции присваивания для всех полей класса


16) шаблонные функции
Шаблоны позволяют передавать тип как бы в качестве аргумента для генерации функции. Если тип определяется однозначно, то компилятор может вывести его сам при инстанцировании шаблона (генерация кода с конкретным типом).

Пример examples\2.


17) шаблонные классы (параметризованные типы данных).

Пример examples\3.


18) контейнеры стандартной библиотеки
Реализованы как шаблонные классы

string - контейнер для представления строк
Стоит использовать всегда вместо char *.

vector - контейнер для динамически расширяемых массивов
Стоит использовать всегда вместо динамических массивов.
Вектор почти такой же как массив (с точки зрения использования), только лучше (но, возможно, медленней). Умеет динамически изменять свой размер.

Пример examples\4.


Задание
Реализовать шаблонную функцию пузырьковой сортировки контейнера в терминах итераторов.
template<class Iter>
void sort (Iter begin, Iter end) {
	Iter p = begin;
}



19) открытое наследование
Возможность производных классам наследовать методы и поля родительского класса.
Дочерний класс является разновидностью родительского (т.е. везде где хотят видеть родительский класс, можно передавать дочерний) или говорят, что дочерний класс является разновидностью (специализацией) родительского.
Дочерние классы могут перегружать (переопределять) методы родительского.

Так как везде вместо родительского класса можно передавать дочерний, для указателя(ссылки) на родительский класс можем выделить два понятия:
- статический тип (тот, который указан при компиляции)
- динамический тип (тип того объекта, указателем на который проинициализировали указатель)
При передаче по значению понятие динамического типа теряет смысл.

Обычные методы класса (даже перегруженные в дочернем) вызываются по статическому типу указателя.
Виртуальные методы класса (помеченные ключевым словом virtual) вызываются по динамическому типу указателя (ссылки).
Если в классе присутствует хотя бы один виртуальный метод, то создаётся таблица виртуальных функций, через которую и вызываются виртуальные функции. Такой механизм еще называют поздним связыванием (т.к. какая именно функция будет вызвана определяется во время исполнения, а не компиляции).

Примеры examples\5, examples\6.
